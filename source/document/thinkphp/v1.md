---
title: 辅助 ThinkPHP 框架的工具集合(v1)
toc: true
---

安装

```shell
composer require kain/think-bit
```

## Facade 门面

### Redis 缓存

PhpRedis 操作类，使用前请确实是否已安装 [Redis](http://pecl.php.net/package/redis) 扩展，你需要在主配置或对应的模块下创建配置 `config/redis.php`，例如：

```php
return [
    'connect' => 'localhost',
    'port' => 6379,
    'auth' => '12345678',
    'select' => 0
];
```

- connect `string` 连接地址
- port `int` 端口
- auth `string` 验证密码
- select `int` 库号

#### 定义 Redis 操作模型

- model ($index)
  - index `int|null` 库号，默认 `null`
  - return `Redis`

设置一个字符串缓存

```php
use think\bit\facade\Redis;

Redis::model()->set('hello', 'world');
```

#### 定义 Redis 事务处理

- transaction(Closure $closure)
  - closure `Closure`
  - return `boolean`

执行一段缓存事务设置

```php
use think\bit\facade\Redis;

Redis::transaction(function (\Redis $redis) {
    return (
        $redis->set('name1', 'js') &&
        $redis->set('name2', 'php')
    );
});
// true or false
```

### Mongo 数据库

MongoDB 数据库的操作类，使用前请确实是否已安装 [MongoDB](http://pecl.php.net/package/mongodb) 扩展，你需要在主配置或对应的模块下创建配置 `config/mongo.php`，例如：

```php
return [
    'uri' => 'mongodb://127.0.0.1:27017',
    'uriOptions' => [],
    'driverOptions' => [],
    'database' => 'test'
];
```

- uri `string` 连接地址

```
mongodb://[username:password@]host1[:port1][,...hostN[:portN]]][/[database][?options]]
```

- uriOptions `array` 等于 `[?options]`
- driverOptions `array` 驱动参数
- database `string` 默认数据库

#### 指向数据库

- Db($database = '')
  - database `string` 数据库名称，默认值为配置默认数据库
  - return `\MongoDB\Database`

查询数据

```php
$result = Mgo::Db()
    ->selectCollection('api')
    ->find();
return $result->toArray();
```

写入数据

```php
$result = Mgo::Db('center')->selectCollection('admin')->insertOne([
    'name' => 'kain',
    'status' => 1,
    'create_time' => new \MongoDB\BSON\UTCDateTime(time() * 1000),
    'update_time' => new \MongoDB\BSON\UTCDateTime(time() * 1000)
])->isAcknowledged();
return $result;
```

更多操作可参考 [MongoDB PHP Library](https://docs.mongodb.com/php-library/current/reference/) Reference.

### Rabbit 消息队列

RabbitMQ 消息队列 AMQP 操作类，使用前请确实是否已安装 `php-amqplib/php-amqplib`，如未安装请手动执行

```shell
composer require php-amqplib/php-amqplib
```

当前 window 系统下需要使用 `"php-amqplib/php-amqplib": "^2.8.2-rc3"` 才可正常运行

#### 连接参数 :id=args

默认下 rabbitmq 连接参数为：

| 配置名称            | 默认值    | 说明             |
| ------------------- | --------- | ---------------- |
| hostname            | localhost | AMQP 连接地址    |
| port                | 5672      | AMQP 连接端口    |
| username            | guest     | 连接用户         |
| password            | guest     | 连接用户口令     |
| virualhost          | /         | 虚拟主机         |
| insist              | false     | 不允许代理重定向 |
| login_method        | AMQPLAIN  | 登录方法         |
| login_response      | null      | 登录响应         |
| locale              | en_US     | 国际化           |
| connection_timeout  | 3.0       | 连接超时         |
| read_write_timeout  | 3.0       | 读写超时         |
| context             | null      | 内容             |
| keepalive           | false     | 保持连接         |
| heartbeat           | 0         | 连接心跳         |
| channel_rpc_timeout | 0.0       | 信道 RPC 超时    |

你需要在主配置或对应的模块下创建配置 `config/rabbitmq.php`，例如：

```php
return [
    'hostname' => 'localhost',
    'port' => 5672,
    'username' => 'guest',
    'password' => 'guest',
];
```

也可以配合 Env 实现开发、生产分离配置：

```php
return [
    'hostname' => env('rabbitmq.hostname', 'localhost'),
    'port' => env('rabbitmq.port', 5672),
    'username' => env('rabbitmq.username', 'guest'),
    'password' => env('rabbitmq.password', 'guest'),
];
```

#### 创建默认信道

- start($closure, $args = [], $config = [])
  - closure `Closure` 信道处理
  - args `array` 连接参数
  - config `array` 操作配置

| 操作配置名称 | 类型    | 默认值 | 说明        |
| ------------ | ------- | ------ | ----------- |
| transaction  | boolean | false  | 开启事务    |
| channel_id   | string  | null   | 定义信道 ID |
| reply_code   | int     | 0      | 回复码      |
| reply_text   | string  | ''     | 回复文本    |
| method_sig   | array   | [0,0]  | -           |

```php
Rabbit::start(function () {
    Rabbit::queue('hello')->create();
});
```

#### 创建自定义信道

- connect($closure, $args = [], $config = [])
  - closure `Closure` 信道处理
  - args `array` 连接参数
  - config `array` 操作配置

| 操作配置名称 | 类型    | 默认值 | 说明        |
| ------------ | ------- | ------ | ----------- |
| transaction  | boolean | false  | 开启事务    |
| channel_id   | string  | null   | 定义信道 ID |
| reply_code   | int     | 0      | 回复码      |
| reply_text   | string  | ''     | 回复文本    |
| method_sig   | array   | [0,0]  | -           |

```php
Rabbit::connect(function () {
    Rabbit::queue('hello')->create();
}, [
    'hostname' => 'developer.com',
    'port' => 5672,
    'username' => 'kain',
    'password' => '******'
]);
```

#### 获取连接对象

- native()
  - return `AMQPStreamConnection`

```php
Rabbit::start(function () {
    dump(Rabbit::native());
    dump(Rabbit::native()->getChannelId());
});
```

#### 获取信道

- channel()
  - return `AMQPChannel`

```php
Rabbit::start(function () {
    dump(Rabbit::native());
    dump(Rabbit::native()->getChannelId());
});
```

#### 创建消息对象

- message($text = '', $config = [])
  - text `string|array` 消息
  - config `array` 操作配置
  - return `AMQPMessage`

```php
Rabbit::start(function () {
    Rabbit::message('test');
});
```

#### 发布消息

- publish($text = '', $config = [])
  - text `string|array` 消息
  - config `array` 操作配置

```php
 Rabbit::start(function () {
    Rabbit::exchange('extest')->create('direct');
    Rabbit::queue('hello')->create();
    Rabbit::queue('hello')->bind('extest', [
        'routing_key' => 'rtest'
    ]);
    Rabbit::publish('test', [
        'exchange' => 'extest',
        'routing_key' => 'rtest'
    ]);
});
```

#### 交换器操作类

- exchange($exchange)
  - exchange `string` 交换器名称
  - return `Exchange` 交换器类

```php
Rabbit::start(function () {
    $exchange = Rabbit::exchange('extest');
});
```

##### 声明交换器

- ->create($type, $config = [])
  - type `string` 交换器类型 (direct、headers、fanout、topic)
  - config `array` 操作配置
  - return `mixed|null`

| 操作配置名称 | 类型    | 默认值 | 说明             |
| ------------ | ------- | ------ | ---------------- |
| passive      | boolean | false  | 检验队列是否存在 |
| durable      | boolean | false  | 是否持久化       |
| auto_delete  | boolean | true   | 自动删除         |
| internal     | boolean | false  | 仅交换绑定有效   |
| nowait       | boolean | false  | 客户端不等待回复 |
| arguments    | array   | []     | 扩展参数         |
| ticket       | string  | null   | -                |

```php
Rabbit::start(function () {
    Rabbit::exchange('extest')->create('direct');
});
```

##### 起源交换器绑定交换器

- ->bind($destination, $config = [])
  - destination `string` 绑定交换器
  - config `array` 操作配置
  - return `mixed|null`

| 操作配置名称 | 类型    | 默认值 | 说明             |
| ------------ | ------- | ------ | ---------------- |
| routing_key  | string  | ''     | 路由键           |
| nowait       | boolean | false  | 客户端不等待回复 |
| arguments    | array   | []     | 扩展参数         |
| ticket       | string  | null   | -                |

```php
Rabbit::start(function () {
    Rabbit::exchange('extest')->create('direct');
    Rabbit::exchange('newtest')->create('direct');
    Rabbit::exchange('newtest')->bind('extest');
});
```

##### 起源交换器解除绑定的交换器

- ->unbind($destination, $config = [])
  - destination `string` 绑定交换器
  - config `array` 操作配置
  - return `mixed`

| 操作配置名称 | 类型    | 默认值 | 说明             |
| ------------ | ------- | ------ | ---------------- |
| routing_key  | string  | ''     | 路由键           |
| nowait       | boolean | false  | 客户端不等待回复 |
| arguments    | array   | []     | 扩展参数         |
| ticket       | string  | null   | -                |

```php
Rabbit::start(function () {
    Rabbit::exchange('extest')->create('direct');
    Rabbit::exchange('newtest')->create('direct');
    Rabbit::exchange('newtest')->bind('extest');
    Rabbit::exchange('newtest')->unbind('extest');
});
```

##### 删除交换器

- ->delete($config = [])
  - config `array` 操作配置
  - return `mixed|null`

| 操作配置名称 | 类型    | 默认值 | 说明                       |
| ------------ | ------- | ------ | -------------------------- |
| if_unused    | boolean | false  | 仅删除没有队列绑定的交换器 |
| nowait       | boolean | false  | 客户端不等待回复           |
| ticket       | string  | null   | -                          |

```php
Rabbit::start(function () {
    Rabbit::exchange('extest')->delete();
});
```

#### 队列操作类

- queue($queue)
  - queue `string` 队列名称
  - return `Queue`

```php
Rabbit::start(function () {
    $queue = Rabbit::queue('hello');
    $queue->create();
});
```

##### 声明队列

- ->create($config = [])
  - config `array` 操作配置
  - return `mixed|null`

| 操作配置名称 | 类型    | 默认值 | 说明             |
| ------------ | ------- | ------ | ---------------- |
| passive      | boolean | false  | 检验队列是否存在 |
| durable      | boolean | false  | 是否持久化       |
| exclusive    | boolean | false  | 排除队列         |
| auto_delete  | boolean | true   | 自动删除         |
| nowait       | boolean | false  | 客户端不等待回复 |
| arguments    | array   | []     | 扩展参数         |
| ticket       | string  | null   | -                |

```php
Rabbit::start(function () {
    Rabbit::queue('hello')->create();
});
```

##### 绑定队列

- ->bind($exchange, $config = [])
  - exchange `string` 交换器名称
  - config `array` 操作配置
  - return `mixed|null`

| 操作配置名称 | 类型    | 默认值 | 说明             |
| ------------ | ------- | ------ | ---------------- |
| routing_key  | string  | ''     | 路由键           |
| nowait       | boolean | false  | 客户端不等待回复 |
| arguments    | array   | []     | 扩展参数         |
| ticket       | string  | null   | -                |

```php
Rabbit::start(function () {
    Rabbit::exchange('extest')->create('direct');
    $queue = Rabbit::queue('hello');
    $queue->create();
    $queue->bind('extest');
});
```

##### 解除绑定

- ->unbind($exchange, $config = [])
  - exchange `string`
  - config `array` 操作配置
  - return `mixed`

| 操作配置名称 | 类型   | 默认值 | 说明     |
| ------------ | ------ | ------ | -------- |
| routing_key  | string | ''     | 路由键   |
| arguments    | array  | []     | 扩展参数 |
| ticket       | string | null   | -        |

```php
Rabbit::start(function () {
    Rabbit::exchange('extest')->create('direct');
    $queue = Rabbit::queue('hello');
    $queue->create();
    $queue->bind('extest');
    $queue->unbind('extest');
});
```

##### 清除队列

- ->purge($config = [])
  - config `array` 操作配置
  - return `mixed|null`

| 操作配置名称 | 类型   | 默认值 | 说明     |
| ------------ | ------ | ------ | -------- |
| arguments    | array  | []     | 扩展参数 |
| ticket       | string | null   | -        |

```php
Rabbit::start(function () {
    Rabbit::exchange('extest')->create('fanout');
    $queue = Rabbit::queue('hello');
    $queue->create();
    $queue->bind('extest');
    Rabbit::publish('message', [
        'exchange' => 'extest',
    ]);
    $queue->purge();
});
```

##### 删除队列

- ->delete($config = [])
  - config `array` 操作配置
  - return `mixed|null`

| 操作配置名称 | 类型    | 默认值 | 说明                       |
| ------------ | ------- | ------ | -------------------------- |
| if_unused    | boolean | false  | 仅删除没有队列绑定的交换器 |
| if_empty     | boolean | false  | 完全清空队列               |
| arguments    | array   | []     | 扩展参数                   |
| ticket       | string  | null   | -                          |

`if_empty` 删除队列时，如果在服务器配置中定义了任何挂起的消息，则会将任何挂起的消息发送到死信队列，并且队列中的所有使用者都将被取消

```php
Rabbit::start(function () {
    $queue = Rabbit::queue('hello');
    $queue->create();
    $queue->delete();
});
```

##### 获取队列信息

- ->get($config = [])
  - config `array` 操作配置
  - return `mixed`

| 操作配置名称 | 类型    | 默认值 | 说明         |
| ------------ | ------- | ------ | ------------ |
| no_ack       | boolean | false  | 手动确认消息 |
| ticket       | string  | null   | -            |

```php
Rabbit::start(function () {
    Rabbit::exchange('extest')->create('fanout');
    $queue = Rabbit::queue('hello');
    $queue->create();
    $queue->bind('extest');
    Rabbit::publish('message', [
        'exchange' => 'extest',
    ]);
    dump($queue->get()->body);
});

// message
```

#### 消费者操作类

- consumer($consumer)
  - consumer `string` 消费者名称
  - return `Consumer`

##### 启用消费者

- ->start($queue, $config = [])
  - queue `string` 队列名称
  - config `array` 操作配置
  - return `mixed|string`

| 操作配置名称 | 类型    | 默认值 | 说明             |
| ------------ | ------- | ------ | ---------------- |
| no_local     | boolean | false  | 独占消费         |
| no_ack       | boolean | false  | 手动确认消息     |
| exclusive    | boolean | false  | 排除队列         |
| nowait       | boolean | false  | 客户端不等待回复 |
| callback     | Closure | null   | 回调函数         |
| arguments    | array   | []     | 扩展参数         |
| ticket       | string  | null   | -                |

`no_local` 请求独占消费者访问权限，这意味着只有此消费者才能访问队列

##### 结束消费者

- ->cancel($config = [])
  - config `array` 操作配置
  - return `mixed`

| 操作配置名称 | 类型    | 默认值 | 说明             |
| ------------ | ------- | ------ | ---------------- |
| nowait       | boolean | false  | 客户端不等待回复 |
| noreturn     | boolean | false  | -                |

#### 确认消息

- ack($delivery_tag, $multiple = false)
  - delivery_tag `string` 标识
  - multiple `boolean` 批量

#### 拒绝传入的消息

- reject($delivery_tag, $requeue = false)
  - delivery_tag `string` 标识
  - requeue `boolean` 重新发送

#### 拒绝一个或多个收到的消息

- nack($delivery_tag, $multiple = false, $requeue = false)
  - delivery_tag `string` 标识
  - multiple `boolean` 批量
  - requeue `boolean` 重新发送

#### 重新发送未确认的消息

- revover($requeue = false)
  - requeue `boolean` 重新发送
  - return `mixed`

### Cipher 密码

Cipher 是用于加密的工具函数，首先要定义配置 `config/cipher.php`

```php
return [
    'key' => env('cipher.key'),
    'iv' => env('cipher.iv')
];
```

- key `string` 加密密钥
- iv `string` 偏移量

#### 加密明文

- encrypt($context, $key, $iv)
  - context `string` 明文
  - key `string` 自定义密钥
  - iv `string` 自定义偏移量
  - Return `string` 密文

```php
dump(Cipher::encrypt('123'));

// s7Tkeof7utaDU4tVsTSbyA==
```

#### 解密密文

- decrypt($secret, $key, $iv)
  - secret `string` 密文
  - key `string` 自定义密钥
  - iv `string` 自定义偏移量
  - Return `string` 明文

```php
$secret = Cipher::encrypt('123');

dump($secret);
// s7Tkeof7utaDU4tVsTSbyA==
dump(Cipher::decrypt($secret));
// 123
```

#### 加密数组为密文

- encryptArray($data, $key, $iv)
  - data `array` 数组
  - key `string` 自定义密钥
  - iv `string` 自定义偏移量
  - Return `string` 密文

```php
dump(Cipher::encryptArray([1, 2, 3]));

// eFIs2OR2/IXC3vv3febOVA==
```

#### 解密密文为数组

- decryptArray($secret, $key, $iv)
  - secret `string` 密文
  - key `string` 自定义密钥
  - iv `string` 自定义偏移量
  - Return `array`

```php
$secret = Cipher::encryptArray([1, 2, 3]);

dump($secret);
// eFIs2OR2/IXC3vv3febOVA==
dump(Cipher::decryptArray($secret));
// array (size=3)
//   0 => int 1
//   1 => int 2
//   2 => int 3
```

### Tools 工具

#### 生成 uuid

- uuid($version, $namespace, $name)
  - version `string` 为 uuid 型号，其中包含 `v1`、`v3`、`v4`、`v5`，默认 `v4`
  - namespace `string` 命名空间，使用在 `v3`、`v5`
  - name `string` 名称，使用在 `v3`、`v5`
  - return `string`

```php
dump(Tools::uuid());
// '4f38cd10-3518-4656-95a3-9cbb4d5a8f25'
dump(Tools::uuid('v1'));
// '3fe018b6-1f89-11e9-863d-aa151017e551'
dump(Tools::uuid('v3', Uuid::NAMESPACE_DNS, 'van'));
// '88124da6-a376-3c77-8fb1-456250a33254'
dump(Tools::uuid('v5', Uuid::NAMESPACE_DNS, 'van'));
// '72ca19ff-6897-5a8e-80c4-ed5d3b753115'
```

| UUID Version | 说明                    |
| ------------ | ----------------------- |
| v1           | 基于时间的 UUID         |
| v3           | 基于名字的 UUID（MD5）  |
| v4           | 随机 UUID               |
| v5           | 基于名字的 UUID（SHA1） |

#### 生产订单号

- orderNumber($service_code, $product_code, $user_code)
  - service_code `string` 业务码
  - product_code `string` 产品码
  - user_code `string` 用户码
  - return `string`

```php
dump(Tools::orderNumber('2', '100', '555'));

// 28100154830173082555
```

#### 随机数 16 位

- random()

```php
dump(Tools::random());

// 3nnoIk3XbVphym4k
```

#### 随机数 8 位

- randomShort()

```php
dump(Tools::randomShort());

// 2maJYwas
```

### Lists 列表数组

ArrayLists 列表数组操作类

#### 列表数组初始化

- data($lists)
  - lists `array` 传入初始化的数组
  - return `BitLists`

```php
$lists = Lists::data([1, 2, 3, 4, 5, 6]);

dump($lists->toArray());
// array (size=6)
//   0 => int 1
//   1 => int 2
//   2 => int 3
//   3 => int 4
//   4 => int 5
//   5 => int 6
```

#### 获取数组大小

- size()
  - return `int`

```php
$lists = Lists::data([1, 2, 3, 4, 5, 6]);
$size = $lists->size();

dump($size);
// 6
```

#### 设置键值

- set($key, $value)
  - key `string` 键名
  - value `string` 键值

```php
$lists = Lists::data([1, 2, 3, 4, 5, 6]);
$lists->set('name', 'test');

dump($lists->toArray());
// array (size=7)
//   0 => int 1
//   1 => int 2
//   2 => int 3
//   3 => int 4
//   4 => int 5
//   5 => int 6
//   'name' => string 'test' (length=4)
```

#### 数组加入元素

- add(...$data)
  - data `mixed` 加入的元素

```php
$lists = Lists::data([1, 2, 3, 4, 5, 6]);
$lists->add(7, 8, 9);

dump($lists->toArray());
// array (size=9)
//   0 => int 1
//   1 => int 2
//   2 => int 3
//   3 => int 4
//   4 => int 5
//   5 => int 6
//   6 => int 7
//   7 => int 8
//   8 => int 9
```

#### 向前数组加入元素

- unshift(...$data)
  - data `mixed` 加入的元素

```php
$lists = Lists::data([1, 2, 3, 4, 5, 6]);
 $lists->unshift(-1, 0);

dump($lists->toArray());
// array (size=8)
//   0 => int -1
//   1 => int 0
//   2 => int 1
//   3 => int 2
//   4 => int 3
//   5 => int 4
//   6 => int 5
//   7 => int 6
```

#### 数组是否为空

- isEmpty()
  - return `boolean`

```php
$lists = Lists::data([]);

dump($lists->isEmpty());
// true
```

#### 判断是否存在键名

- has($key)
  - key `string` 键名
  - return `boolean`

```php
$lists = Lists::data([
    'name' => 'test'
]);

dump($lists->has('name'));
// true
```

#### 判断是否存在键值

- contains($value)
  - value `mixed` 键值
  - return `boolean`

```php
$lists = Lists::data([
    'name' => 'test'
]);

dump($lists->contains('test'));
// true
```

#### 获取键值

- get($key)
  - key `mixed` 键名
  - return `mixed`

```php
$lists = Lists::data([
    'name' => 'test'
]);

dump($lists->get('name'));
// test
```

#### 移除键值

- delete($key)
  - key `mixed` 键名

```php
$lists = Lists::data([
    'name' => 'test'
]);
$lists->delete('name');

dump($lists->toArray());
// array (size=0)
```

#### 数组开头的单元移出元素

- shift()
  - return `mixed` 移出的元素

```php
$lists = Lists::data([1, 2, 3]);
$lists->shift();

dump($lists->toArray());
// array (size=2)
//   0 => int 2
//   1 => int 3
```

#### 数组出栈

- pop()
  - return `mixed` 出栈的元素

```php
$lists = Lists::data([1, 2, 3]);
$lists->pop();

dump($lists->toArray());
// array (size=2)
//   0 => int 1
//   1 => int 2
```

#### 去除重复

- unique()

```php
$lists = Lists::data([1, 1, 2, 2, 3]);
$lists->unique();

dump($lists->toArray());
// array (size=3)
//   0 => int 1
//   2 => int 2
//   4 => int 3
```

#### 清除数据

- clear()

```php
$lists = Lists::data([1, 1, 2, 2, 3]);
$lists->clear();

dump($lists->toArray());
// array (size=0)
```

#### 返回键名

- keys()
  - return `array` 所有键名

```php
$lists = Lists::data([
    'name' => 'van',
    'age' => 100,
    'sex' => 0
]);

dump($lists->keys());
// array (size=3)
//   0 => string 'name' (length=4)
//   1 => string 'age' (length=3)
//   2 => string 'sex' (length=3)
```

#### 返回键值

- values()
  - return `array` 所有键值

```php
$lists = Lists::data([
    'name' => 'van',
    'age' => 100,
    'sex' => 0
]);

dump($lists->values());
// array (size=3)
//   0 => string 'van' (length=3)
//   1 => int 100
//   2 => int 0
```

#### 搜索给定的值，返回键名

- indexOf($value)
  - value `mixed` 键值
  - return `string` 键名

```php
$lists = Lists::data([
    'name' => 'van',
    'age' => 100,
    'sex' => 0
]);

dump($lists->indexOf('van'));
// name
```

#### 数组遍历返回

- map(Closure $closure)
  - closure `Closure` 闭包函数
  - return `array`

```php
$lists = Lists::data([
    [
        'product' => 'test1',
        'price' => 10
    ],
    [
        'product' => 'test2',
        'price' => 20
    ]
]);

$other_lists = $lists->map(function ($v) {
    $v['price'] += 10;
    return $v;
});

dump($other_lists);
// array (size=2)
//   0 =>
//     array (size=2)
//       'product' => string 'test1' (length=5)
//       'price' => int 20
//   1 =>
//     array (size=2)
//       'product' => string 'test2' (length=5)
//       'price' => int 30
```

#### 数组过滤

- filter(Closure $closure)
  - closure `Closure` 闭包函数
  - return `array`

```php
$lists = Lists::data([
    [
        'product' => 'test1',
        'price' => 10
    ],
    [
        'product' => 'test2',
        'price' => 20
    ],
    [
        'product' => 'test3',
        'price' => 30
    ]
]);

$other_lists = $lists->filter(function ($v) {
    return $v['price'] > 10;
});

dump($other_lists);
// array (size=2)
//   1 =>
//     array (size=2)
//       'product' => string 'test2' (length=5)
//       'price' => int 20
//   2 =>
//     array (size=2)
//       'product' => string 'test3' (length=5)
//       'price' => int 30
```

#### 数组切片

- slice($offset, $length)
  - offset `int` 起始
  - length `int` 长度
  - return `array`

```php
$lists = Lists::data([1, 2, 3, 4, 5]);

dump($lists->slice(1, 3));
// array (size=3)
//   0 => int 2
//   1 => int 3
//   2 => int 4
```

#### 获取数组

- toArray()
  - return `array`

```php
$lists = Lists::data([
    [
        'product' => 'test1',
        'price' => 10
    ],
    [
        'product' => 'test2',
        'price' => 20
    ],
    [
        'product' => 'test3',
        'price' => 30
    ]
]);

dump($lists->toArray());
// array (size=3)
//   0 =>
//     array (size=2)
//       'product' => string 'test1' (length=5)
//       'price' => int 10
//   1 =>
//     array (size=2)
//       'product' => string 'test2' (length=5)
//       'price' => int 20
//   2 =>
//     array (size=2)
//       'product' => string 'test3' (length=5)
//       'price' => int 30
```

#### 转为 Json

- toJson()
  - return `string`

```php
$lists = Lists::data([
    [
        'product' => 'test1',
        'price' => 10
    ],
    [
        'product' => 'test2',
        'price' => 20
    ],
    [
        'product' => 'test3',
        'price' => 30
    ]
]);

dump($lists->toJson());
// [{"product":"test1","price":10},{"product":"test2","price":20},{"product":"test3","price":30}]
```

#### 转为二进制

- toBinary()
  - return `string`

```php
$lists = Lists::data([
    [
        'product' => 'test1',
        'price' => 10
    ],
    [
        'product' => 'test2',
        'price' => 20
    ],
    [
        'product' => 'test3',
        'price' => 30
    ]
]);

dump($lists->toBinary());
// ���product�test1�price
// ��product�test2�price��product�test3�price
```

#### 转为树形结构

- toTree($id_name = 'id', $parent_name = 'parent', $child_name = 'children', $top_parent = 0) :id=to_tree
  - id_name `string` 数组主键名称
  - parent_name `string` 数组父级关联名称
  - child_name `string` 树形子集名称定义
  - top_parent `int|string` 最高级父级
  - return `array`

```php
$lists = Lists::data([
    [
        'id' => 1,
        'name' => 'node1',
        'parent' => 0
    ],
    [
        'id' => 2,
        'name' => 'node2',
        'parent' => 0
    ],
    [
        'id' => 3,
        'name' => 'node3',
        'parent' => 1
    ],
    [
        'id' => 4,
        'name' => 'node4',
        'parent' => 1
    ],
    [
        'id' => 5,
        'name' => 'node5',
        'parent' => 4
    ],
    [
        'id' => 6,
        'name' => 'node6',
        'parent' => 2
    ],
]);

$tree = $lists->toTree();
```

### Collect 数据收集

Collect 是用于简化数据收集消息队列写入的函数, 首先需要 `Rabbitmq` 配置 `config/rabbitmq.php`, 然后在主配置或对应的模块下设置配置 `config/collect.php`

```php
return [
    'authorization' => [
        'appid' => 'xxx',
        'secret' => 'xxx'
    ],
    'exchange' => 'collect',
    'queue' => 'collect'
];
```

- authorization 执行授权
  - appid 自定义应用 ID
  - secret 应用密钥
- exchange 交换器
- queue 队列

#### 数据收集队列写入

- push($motivation, $data = [], $time_field = [])
  - motivation `string` 行为命名
  - data `array` 数据
  - time_field `array` 时间字段

使用如下

```php
Collect::push('pay_order', [
    'order' => Tools::orderNumber('L1', 'A1', '1100'),
    'product' => Tools::uuid(),
    'user' => Tools::uuid(),
    'create_time' => time(),
    'update_time' => time()
], ['create_time', 'update_time']);
```

使用前对应配置队列写入服务 https://github.com/kainonly/collection-service

## Middleware 中间件

### CORS 跨站访问

使用 CORS 中间定义跨站的请求策略，你需要在主配置或对应的模块下创建配置 `config/cors.php`，例如：

```php
return [
    'allow_origin' => [
        'https://api.developer.com'
    ],
    'with_credentials' => true,
    'option_max_age' => 2592000,
    'methods' => 'GET,OPTIONS,POST,PUT',
    'headers' => 'Content-Type,X-Requested-With,X-Token'
];
```

注册中间件，修改主配置目录下 `config/middleware.php`

```php
return [
    'cors' => \bit\middleware\Cors::class,
];
```

在控制器中使用

```php
namespace app\index\controller;

use think\Controller;

class Index extends Controller
{
    protected $middleware = ['cors'];

    public function index()
    {
        return 'index';
    }
}
```

在路由中使用

```php
Route::rule('index','index')->middleware('cors');
```

#### 配置详情

| 名称             | 类型    | 说明                      |
| ---------------- | ------- | ------------------------- |
| allow_origin     | array   | 允许跨域的域名            |
| with_credentials | boolean | 允许 ajax 请求携带 Cookie |
| option_max_age   | boolean | 缓存 OPTIONS 请求         |
| methods          | string  | 允许请求类型              |
| headers          | string  | 允许定义的头部            |

如果允许所有域名跨域，则将 `allow_origin` 设置为 `[*]`，但 `with_credentials` 将失效，并且 ajax 请求不能携带 cookie。

### LogSystem 系统日志

使用 LogSystem 系统日志, 首先需要 `Rabbitmq` 配置 `config/rabbitmq.php` , 然后在主配置或对应的模块下设置配置 `config/log.php`

```php
return [
    'publish' => 'api.developer.com',
    'exchange' => 'log.system',
    'queue' => 'log.system'
];
```

- publish 发布域名
- exchange 交换器
- queue 队列

注册中间件，修改主配置目录下 `config/middleware.php`

```php
return [
    'log_system' => think\bit\middleware\LogSystem::class
];
```

在控制器中使用

```php
namespace app\system\controller;

use think\Controller;

class Base extends Controller
{
    protected $middleware = ['log_system'];
}
```

使用前对应配置队列写入服务 https://github.com/kainonly/collection-service

## Abstract 抽象类

### BitController 通用控制器

BitController 是辅助框架的主控制器，使用辅助处理则需要继承该控制器

```php
use think\bit\common\BitController;

class Base extends BitController
{
    // customize
}
```

#### 通用属性

| 属性名称 | 类型   | 默认值 | 说明           |
| -------- | ------ | ------ | -------------- |
| model    | string | null   | 模型名称       |
| post     | array  | []     | 请求包含的数据 |

#### 获取列表数据请求属性

| 属性名称               | 类型   | 默认值                            | 说明                       |
| ---------------------- | ------ | --------------------------------- | -------------------------- |
| lists_origin_condition | array  | []                                | 列表数据从后端设定制约条件 |
| lists_origin_orders    | string | create_time desc                  | 列表数据设定排序           |
| lists_origin_field     | array  | ['update_time,create_time', true] | 列表数据指定返回字段       |

#### 获取分页数据请求属性

| 属性名称        | 类型   | 默认值                            | 说明                           |
| --------------- | ------ | --------------------------------- | ------------------------------ |
| lists_condition | array  | []                                | 分页列表数据从后端设定制约条件 |
| lists_orders    | string | create_time desc                  | 分页列表数据排序               |
| lists_field     | array  | ['update_time,create_time', true] | 分页列表数据指定返回字段       |

#### 获取单条数据请求属性

| 属性名称      | 类型  | 默认值                            | 说明             |
| ------------- | ----- | --------------------------------- | ---------------- |
| get_validate  | array | ['id' => 'require']               | 单条数据验证器   |
| get_condition | array | []                                | 单条数据制约条件 |
| get_field     | array | ['update_time,create_time', true] | 单条数据返回字段 |

#### 新增数据请求属性

| 属性名称          | 类型  | 默认值                                | 说明               |
| ----------------- | ----- | ------------------------------------- | ------------------ |
| add_before_result | array | ['error' => 1,'msg' => 'fail:before'] | 新增自定义前置返回 |
| add_after_result  | array | ['error' => 1,'msg' => 'fail:after']  | 新增自定义后置返回 |

#### 修改数据请求属性

| 属性名称           | 类型    | 默认值                                 | 说明               |
| ------------------ | ------- | -------------------------------------- | ------------------ |
| edit_validate      | array   | ['id' => 'require','switch' => 'bool'] | 修改数据验证器     |
| edit_before_result | array   | ['error' => 1,'msg' => 'fail:before']  | 修改自定义前置返回 |
| edit_after_result  | array   | ['error' => 1,'msg' => 'fail:after']   | 修改自定义后置返回 |
| edit_status_switch | boolean | false                                  | 是否为状态切换请求 |

#### 删除数据请求属性

| 属性名称             | 类型  | 默认值                                | 说明                     |
| -------------------- | ----- | ------------------------------------- | ------------------------ |
| delete_validate      | array | ['id' => 'require']                   | 删除数据验证器           |
| delete_before_result | array | ['error' => 1,'msg' => 'fail:before'] | 删除自定义前置返回       |
| delete_prep_result   | array | ['error' => 1,'msg' => 'fail:prep']   | 删除自定义含事务前置返回 |
| delete_after_result  | array | ['error' => 1,'msg' => 'fail:after']  | 删除自定义后置返回       |

### Bedis 缓存类

Redis 在给我们带来优异的读写性能时，同时也带来了恢复性差、团队协作性困难等问题，因此建议在我们所使用到的缓存键中分别定义缓存的刷新方式以及获取方式等，Bedis 则是这样一个抽象类。使用 Bedis 缓存类为接口定义 HASH 缓存

```php
class ApiHash extends Bedis
{
    protected $key = 'api_hash';

    function refresh()
    {
        $this->redis->del($this->key);
        $lists = Db::name('api')->where([
            'status' => 1
        ])->column('id', 'api');
        if (empty($lists)) return true;
        return $this->redis->hMSet($this->key, $lists);
    }

    public function get($api)
    {
        try {
            if (!$this->redis->exists($this->key)) $this->refresh();
            return $this->redis->hGet($this->key, $api);
        } catch (\Exception $e) {
            return '';
        }
    }
}
```

当接口数据发生更新时则可以使用 `refresh` 函数将缓存刷新

```php
$api = new ApiHash();
$api->refresh();
```

`*缓存的生产设定不建议使用组合数据或一对一来生成，这样会提高数据的耦合度，增大开发与维护的难度*`

通过接口缓存获取对应的接口主键

```php
$api = new ApiHash();
$api->get('admin/get');
```

如果使用事务则实现化时赋值参数

```php
Redis::transaction(function (\Redis $redis) {
    $api = new ApiHash($redis);
    $router = new RouterHash($redis);
    return ($api->refresh() && $router->refresh());
});
// true or false
```

## Bedis 缓存模型

### SmsString 短信验证

手机短信验证码缓存类

#### 设置手机验证码缓存

- factory($phone, $code, $timeout)
  - phone `string`，手机号
  - code `string`，验证码
  - timeout `int`，超时时间，默认 60 秒
  - return `bool`

```php
$sms = new SmsString();
$sms->factory('12345678910', '13125');
```

#### 验证手机验证码

- check($phone, $code, $once)
  - phone `string`，手机号
  - code `string`，验证码
  - once `bool`，验证成功后失效，默认`false`
  - return `bool`

```php
$sms = new SmsString();
$checked = $sms->check('12345678910', '11224');
dump($checked);
// false
$checked = $sms->check('12345678910', '13125');
dump($checked);
// true
$checked = $sms->check('12345678910', '13125', true);
dump($checked);
// true
$checked = $sms->check('12345678910', '13125');
dump($checked);
// false
```

#### 获取验证时间

- time($phone)
  - phone `string`，手机号
  - return `bool|array`

```php
$sms = new SmsString();
$sms->factory('12345678910', '13125', 3600);

$data = $sms->time('12345678910');
dump($data);
// array (size=2)
//   'publish_time' => int 1548644216
//   'timeout' => int 3600
```

- publish_time 指发布时间
- timeout 指有效时间

## CURD 请求处理库

### GetModel 获取单个数据

如果 post 请求中存在参数 id，那么 where 的存在将成为附加条件，如果 id 不存在，那么可以使用 where 为主要条件

- id `int|string` or `int[]|string[]`
- where `array`，必须使用数组方式来定义

```php
$this->post['where'] = [
    ['name', '=', 'van']
];
```

引入特性，需要定义必须的操作模型 model

```php
use think\bit\traits\GetModel;

class AdminClass extends Base {
    use GetModel;

    protected $model = 'admin';
}
```

自定义获取验证器为 get_validate，默认为

```php
protected $get_validate = [
    'id' => 'require'
];
```

也可以在控制器中针对性修改

```php
use think\bit\traits\GetModel;

class AdminClass extends Base {
    use GetModel;

    protected $model = 'admin';
    protected $get_validate = [
        'id' => 'require',
        'name' => 'require'
    ];
}
```

判断是否有前置处理，则需要调用生命周期 GetBeforeHooks

```php
use think\bit\traits\GetModel;
use think\bit\lifecycle\GetBeforeHooks;

class AdminClass extends Base implements GetBeforeHooks {
    use GetModel;

    protected $model = 'admin';

    public function __getBeforeHooks()
    {
        return true;
    }
}
```

\_\_getBeforeHooks 的返回值为 `false` 则在此结束执行，并返回 get_before_result 属性的值，默认为：

```php
protected $get_before_result = [
    'error' => 1,
    'msg' => 'error:before_fail'
];
```

在生命周期函数中可以通过重写自定义前置返回

```php
use think\bit\traits\GetModel;
use think\bit\lifecycle\GetBeforeHooks;

class AdminClass extends Base implements GetBeforeHooks {
    use GetModel;

    protected $model = 'admin';

    public function __getBeforeHooks()
    {
        $this->get_before_result = [
            'error'=> 1,
            'msg'=> 'error:only'
        ];
        return false;
    }
}
```

如需要给接口在后端就设定固定条件，只需要重写 get_condition，默认为

```php
protected $get_condition = [];
```

例如加入企业主键限制

```php
use think\bit\traits\GetModel;

class AdminClass extends Base {
    use GetModel;

    protected $model = 'admin';
    protected $get_condition = [
        ['enterprise', '=', 1]
    ];
}
```

如需要给接口限制返回字段，只需要重写 get_field，默认为

```php
protected $get_field = ['update_time,create_time', true];
```

例如返回除 update_time 修改时间所有的字段

```php
use think\bit\traits\GetModel;

class AdminClass extends Base {
    use GetModel;

    protected $model = 'admin';
    protected $get_field = ['update_time', true];
}
```

如自定义返回结果，则需要调用生命周期 GetCustom

```php
use think\bit\traits\GetModel;
use think\bit\lifecycle\GetCustom;

class AdminClass extends Base implements GetCustom {
    use GetModel;

    protected $model = 'admin';

    public function __getCustomReturn($data)
    {
        return [
            'error' => 0,
            'data' => $data
        ];
    }
}
```

\_\_getCustomReturn 需要返回整体的响应结果

```php
return [
    'error' => 0,
    'data' => $data
];
```

- data `array` 原数据

### OriginListsModel 获取列表数据

如果 post 请求中存在参数 where，那么它将于 lists_origin_condition 固定条件合并

- where `array` 必须使用数组方式来定义

```php
$this->post['where'] = [
    ['name', '=', 'van']
];
```

模糊查询在 post 请求中加入参数 like，他将于以上条件共同合并

- like `array` 模糊搜索条件
  - field 模糊搜索字段名
  - value 模糊搜索字段值

```json
[{ "field": "name", "value": "a" }]
```

引入特性需要定义必须的操作模型 model

```php
use think\bit\traits\OriginListsModel;

class AdminClass extends Base {
    use OriginListsModel;

    protected $model = 'admin';
}
```

合并模型验证器下 origin 场景，所以需要对应创建验证器场景 validate/AdminClass， 并加入场景 `origin`

```php
use think\Validate;

class AdminClass extends Validate
{
    protected $rule = [
        'status' => 'require',
    ];

    protected $scene = [
        'origin' => ['status'],
    ];
}
```

可定义固定条件属性 `$this->lists_origin_condition`，默认为 `[]`

```php
use think\bit\traits\OriginListsModel;

class NoBodyClass extends Base {
    use OriginListsModel;

    protected $model = 'nobody';
    protected $lists_origin_condition = [
        ['status', '=', 1]
    ];
}
```

如自定义前置处理，则需要调用生命周期 OriginListsBeforeHooks

```php
use think\bit\traits\OriginListsModel;
use think\bit\lifecycle\OriginListsBeforeHooks;

class AdminClass extends Base implements OriginListsBeforeHooks {
    use OriginListsModel;

    protected $model = 'admin';

    public function __originListsBeforeHooks()
    {
        return true;
    }
}
```

\_\_originListsBeforeHooks 的返回值为 `false` 则在此结束执行，并返回 lists_origin_before_result 属性的值，默认为：

```php
protected $lists_origin_before_result = [
    'error' => 1,
    'msg' => 'error:before_fail'
];
```

在生命周期函数中可以通过重写自定义前置返回

```php
use think\bit\traits\OriginListsModel;
use think\bit\lifecycle\OriginListsBeforeHooks;

class AdminClass extends Base implements OriginListsBeforeHooks {
    use OriginListsModel;

    protected $model = 'admin';

    public function __originListsBeforeHooks()
    {
        $this->lists_origin_before_result = [
            'error'=> 1,
            'msg'=> 'error:only'
        ];
        return false;
    }
}
```

如需要给接口在后端就设定固定条件，只需要重写 lists_origin_condition，默认为

```php
protected $lists_origin_condition = [];
```

例如加入企业主键限制

```php
use think\bit\traits\OriginListsModel;

class AdminClass extends Base {
    use OriginListsModel;

    protected $model = 'admin';
    protected $lists_origin_condition = [
        ['enterprise', '=', 1]
    ];
}
```

如果需要列表按条件排序，只需要重写 lists_origin_orders，默认为

```php
protected $lists_origin_orders = 'create_time desc';
```

例如按年龄进行排序

```php
use think\bit\traits\OriginListsModel;

class AdminClass extends Base {
    use OriginListsModel;

    protected $model = 'admin';
    protected $lists_origin_orders = 'age desc';
}
```

如需要给接口限制返回字段，只需要重写 lists_origin_field，默认为

```php
protected $lists_origin_field = ['update_time,create_time', true];
```

例如返回除 update_time 修改时间所有的字段

```php
use think\bit\traits\OriginListsModel;

class AdminClass extends Base {
    use OriginListsModel;

    protected $model = 'admin';
    protected $lists_origin_field = ['update_time', true];
}
```

如自定义返回结果，则需要调用生命周期 OriginListsCustom

```php
use think\bit\traits\OriginListsModel;
use think\bit\lifecycle\OriginListsCustom;

class AdminClass extends Base implements OriginListsCustom {
    use OriginListsModel;

    protected $model = 'admin';

    public function __originListsCustomReturn(Array $lists)
    {
        return [
            'error' => 0,
            'data' => $lists
        ];
    }
}
```

\_\_originListsCustomReturn 需要返回整体的响应结果

```php
return [
    'error' => 0,
    'data' => $data
];
```

- data `array` 原数据

### ListsModel 获取分页数据

如果 post 请求中存在参数 where，那么它将于 lists_condition 固定条件合并

- where `array` 必须使用数组方式来定义

```php
$this->post['where'] = [
    ['name', '=', 'van']
];
```

模糊查询在 post 请求中加入参数 like，他将于以上条件共同合并

- like `array` 模糊搜索条件
  - field 模糊搜索字段名
  - value 模糊搜索字段值

```json
[{ "field": "name", "value": "a" }]
```

引入特性，需要定义必须的操作模型 model

```php
use think\bit\traits\ListsModel;

class AdminClass extends Base {
    use ListsModel;

    protected $model = 'admin';
}
```

如自定义前置处理，则需要调用生命周期 ListsBeforeHooks

```php
use think\bit\traits\ListsModel;
use think\bit\lifecycle\ListsBeforeHooks;

class AdminClass extends Base implements ListsBeforeHooks {
    use ListsModel;

    protected $model = 'admin';

    public function __listsBeforeHooks()
    {
        return true;
    }
}
```

\_\_listsBeforeHooks 的返回值为 `false` 则在此结束执行，并返回 lists_before_result 属性的值，默认为：

```php
protected $lists_before_result = [
    'error' => 1,
    'msg' => 'error:before_fail'
];
```

在生命周期函数中可以通过重写自定义前置返回

```php
use think\bit\traits\ListsModel;
use think\bit\lifecycle\ListsBeforeHooks;

class AdminClass extends Base implements ListsBeforeHooks {
    use ListsModel;

    protected $model = 'admin';

    public function __listsBeforeHooks()
    {
        $this->lists_before_result = [
            'error'=> 1,
            'msg'=> 'error:only'
        ];
        return false;
    }
}
```

如需要给接口在后端就设定固定条件，只需要重写 lists_condition，默认为

```php
protected $lists_condition = [];
```

例如加入企业主键限制

```php
use think\bit\traits\ListsModel;

class AdminClass extends Base {
    use ListsModel;

    protected $model = 'admin';
    protected $lists_condition = [
        ['enterprise', '=', 1]
    ];
}
```

如果需要列表按条件排序，只需要重写 lists_orders，默认为

```php
protected $lists_orders = 'create_time desc';
```

例如按年龄进行排序

```php
use think\bit\traits\ListsModel;

class AdminClass extends Base {
    use ListsModel;

    protected $model = 'admin';
    protected $lists_orders = 'age desc';
}
```

如需要给接口限制返回字段，只需要重写 lists_field，默认为

```php
protected $lists_field = ['update_time,create_time', true];
```

例如返回除 update_time 修改时间所有的字段

```php
use think\bit\traits\ListsModel;

class AdminClass extends Base {
    use ListsModel;

    protected $model = 'admin';
    protected $lists_field = ['update_time', true];
}
```

如自定义返回结果，则需要调用生命周期 ListsCustom

```php
use think\bit\traits\ListsModel;
use think\bit\lifecycle\ListsCustom;

class AdminClass extends Base implements ListsCustom {
    use ListsModel;

    protected $model = 'admin';

    public function __listsCustomReturn(Array $lists, int $total)
    {
        return [
            'error' => 0,
            'data' => [
                'lists' => $lists,
                'total' => $total,
            ]
        ];
    }
}
```

\_\_listsCustomReturn 需要返回整体的响应结果

```php
return [
    'error' => 0,
    'data' => [
        'lists' => $lists,
        'total' => $total,
    ]
];
```

- data `array` 原数据

### AddModel 新增数据

引入特性，需要定义必须的操作模型 model

```php
use think\bit\traits\AddModel;

class AdminClass extends Base {
    use AddModel;

    protected $model = 'admin';
}
```

合并模型验证器下 add 场景，所以需要对应创建验证器场景 validate/AdminClass， 并加入场景 `add`

```php
use think\Validate;

class AdminClass extends Validate
{
    protected $rule = [
        'name' => 'require',
    ];

    protected $scene = [
        'add' => ['name'],
    ];
}
```

如自定义前置处理，则需要调用生命周期 AddBeforeHooks

```php
use think\bit\traits\AddModel;
use think\bit\lifecycle\AddBeforeHooks;

class AdminClass extends Base implements AddBeforeHooks {
    use AddModel;

    protected $model = 'admin';

    public function __addBeforeHooks()
    {
        return true;
    }
}
```

\_\_addBeforeHooks 的返回值为 `false` 则在此结束执行，并返回 add_before_result 属性的值，默认为：

```php
protected $add_before_result = [
    'error' => 1,
    'msg' => 'error:before_fail'
];
```

在生命周期函数中可以通过重写自定义前置返回

```php
use think\bit\traits\AddModel;
use think\bit\lifecycle\AddBeforeHooks;

class AdminClass extends Base implements AddBeforeHooks {
    use AddModel;

    protected $model = 'admin';

    public function __addBeforeHooks()
    {
        $this->add_before_result = [
            'error'=> 1,
            'msg'=> 'error:only'
        ];
        return false;
    }
}
```

如自定义后置处理，则需要调用生命周期 AddAfterHooks

```php
use think\bit\traits\AddModel;
use think\bit\lifecycle\AddAfterHooks;

class AdminClass extends Base implements AddAfterHooks {
    use AddModel;

    protected $model = 'admin';

    public function __addAfterHooks($pk)
    {
        return true;
    }
}
```

pk 为模型写入后返回的主键，\_\_addAfterHooks 的返回值为 `false` 则在此结束执行进行事务回滚，并返回 add_after_result 属性的值，默认为：

```php
protected $add_after_result = [
    'error' => 1,
    'msg' => 'error:after_fail'
];
```

在生命周期函数中可以通过重写自定义后置返回

```php
use think\bit\traits\AddModel;
use think\bit\lifecycle\AddAfterHooks;

class AdminClass extends Base implements AddAfterHooks {
    use AddModel;

    protected $model = 'admin';

    public function __addAfterHooks($pk)
    {
        $this->add_after_result = [
            'error'=> 1,
            'msg'=> 'error:redis'
        ];
        return false;
    }
}
```

### EditModel 编辑数据

如果 post 请求中存在参数 id，那么 where 的存在将成为附加条件，如果 id 不存在，那么可以使用 where 为主要条件

- id `int|string` or `int[]|string[]`
- where `array`，必须使用数组方式来定义

```php
$this->post['where'] = [
    ['name', '=', 'van']
];
```

引入特性，需要定义必须的操作模型 model

```php
use think\bit\traits\EditModel;

class AdminClass extends Base {
    use EditModel;

    protected $model = 'admin';
}
```

自定义删除验证器为 edit_validate，默认为

```php
protected $edit_validate = [
    'id' => 'require',
    'switch' => 'bool'
];
```

也可以在控制器中针对性修改

```php
use think\bit\traits\EditModel;

class AdminClass extends Base {
    use EditModel;

    protected $model = 'admin';
    protected $edit_validate = [
        'id' => 'require'
        'switch' => 'bool',
        'status' => 'require',
    ];
}
```

合并模型验证器下 edit 场景，所以需要对应创建验证器场景 validate/AdminClass，edit_status_switch 为 `false` 下有效， 并加入场景 `edit`

```php
use think\Validate;

class AdminClass extends Validate
{
    protected $rule = [
        'name' => 'require',
    ];

    protected $scene = [
        'edit' => ['name'],
    ];
}
```

如自定义前置处理，则需要调用生命周期 EditBeforeHooks

```php
use think\bit\traits\EditModel;
use think\bit\lifecycle\EditBeforeHooks;

class AdminClass extends Base implements EditBeforeHooks {
    use EditModel;

    protected $model = 'admin';

    public function __editBeforeHooks()
    {
        return true;
    }
}
```

\_\_editBeforeHooks 的返回值为 `false` 则在此结束执行，并返回 edit_before_result 属性的值，默认为：

```php
protected $edit_before_result = [
    'error' => 1,
    'msg' => 'error:before_fail'
];
```

在生命周期函数中可以通过重写自定义前置返回

```php
use think\bit\traits\EditModel;
use think\bit\lifecycle\EditBeforeHooks;

class AdminClass extends Base implements EditBeforeHooks {
    use EditModel;

    protected $model = 'admin';

    public function __editBeforeHooks()
    {
        $this->edit_before_result = [
            'error'=> 1,
            'msg'=> 'error:only'
        ];
        return false;
    }
}
```

如自定义后置处理，则需要调用生命周期 EditAfterHooks

```php
use think\bit\traits\EditModel;
use think\bit\lifecycle\EditAfterHooks;

class AdminClass extends Base implements EditAfterHooks {
    use EditModel;

    protected $model = 'admin';

    public function __editAfterHooks()
    {
        return true;
    }
}
```

\_\_editAfterHooks 的返回值为 `false` 则在此结束执行进行事务回滚，并返回 edit_after_result 属性的值，默认为：

```php
 protected $edit_after_result = [
    'error' => 1,
    'msg' => 'error:after_fail'
];
```

在生命周期函数中可以通过重写自定义后置返回

```php
use think\bit\traits\EditModel;
use think\bit\lifecycle\EditAfterHooks;

class AdminClass extends Base implements EditAfterHooks {
    use EditModel;

    protected $model = 'admin';

    public function __editAfterHooks()
    {
        $this->edit_after_result = [
            'error'=> 1,
            'msg'=> 'error:redis'
        ];
        return false;
    }
}
```

### DeleteModel 删除数据

如果 post 请求中存在参数 id，那么 where 的存在将成为附加条件，如果 id 不存在，那么可以使用 where 为主要条件

- id `int|string` or `int[]|string[]`
- where `array`，必须使用数组方式来定义

```php
$this->post['where'] = [
    ['name', '=', 'van']
];
```

引入特性，需要定义必须的操作模型 model

```php
use think\bit\traits\DeleteModel;

class AdminClass extends Base {
    use DeleteModel;

    protected $model = 'admin';
}
```

自定义删除验证器为 delete_validate，默认为

```php
protected $delete_validate = [
    'id' => 'require'
];
```

也可以在控制器中针对性修改

```php
use think\bit\traits\DeleteModel;

class AdminClass extends Base {
    use DeleteModel;

    protected $model = 'admin';
    protected $delete_validate = [
        'id' => 'require',
        'name' => 'require'
    ];
}
```

如自定义前置处理，则需要调用生命周期 DeleteBeforeHooks

```php
use think\bit\traits\DeleteModel;
use think\bit\lifecycle\DeleteBeforeHooks;

class AdminClass extends Base implements DeleteBeforeHooks {
    use DeleteModel;

    protected $model = 'admin';

    public function __deleteBeforeHooks()
    {
        return true;
    }
}
```

\_\_deleteBeforeHooks 的返回值为 `false` 则在此结束执行，并返回 delete_before_result 属性的值，默认为：

```php
protected $delete_before_result = [
    'error' => 1,
    'msg' => 'error:before_fail'
];
```

在生命周期函数中可以通过重写自定义前置返回

```php
use think\bit\traits\DeleteModel;
use think\bit\lifecycle\DeleteBeforeHooks;

class AdminClass extends Base implements DeleteBeforeHooks {
    use DeleteModel;

    protected $model = 'admin';

    public function __deleteBeforeHooks()
    {
        $this->delete_before_result = [
            'error'=> 1,
            'msg'=> 'error:only'
        ];
        return false;
    }
}
```

判断是否有存在事务之后模型写入之前的处理，如该周期处理，则需要调用生命周期 DeletePrepHooks

```php
use think\bit\traits\DeleteModel;
use think\bit\lifecycle\DeletePrepHooks;

class AdminClass extends Base implements DeletePrepHooks {
    use DeleteModel;

    protected $model = 'admin';

    public function __deletePrepHooks()
    {
        return true;
    }
}
```

\_\_deletePrepHooks 的返回值为 `false` 则在此结束执行进行事务回滚，并返回 delete_prep_result 属性的值，默认为：

```php
protected $delete_prep_result = [
    'error' => 1,
    'msg' => 'error:prep_fail'
];
```

在生命周期函数中可以通过重写自定义返回

```php
use think\bit\traits\DeleteModel;
use think\bit\lifecycle\DeletePrepHooks;

class AdminClass extends Base implements DeletePrepHooks {
    use DeleteModel;

    protected $model = 'admin';

    public function __deletePrepHooks()
    {
        $this->delete_prep_result = [
            'error'=> 1,
            'msg'=> 'error:insert'
        ];
        return false;
    }
}
```

如自定义后置处理，则需要调用生命周期 DeleteAfterHooks

```php
use think\bit\traits\DeleteModel;
use think\bit\lifecycle\DeleteAfterHooks;

class AdminClass extends Base implements DeleteAfterHooks {
    use DeleteModel;

    protected $model = 'admin';

    public function __deleteAfterHooks()
    {
        return true;
    }
}
```

\_\_deleteAfterHooks 的返回值为 `false` 则在此结束执行进行事务回滚，并返回 delete_after_result 属性的值，默认为：

```php
protected $delete_after_result = [
    'error' => 1,
    'msg' => 'error:after_fail'
];
```

在生命周期函数中可以通过重写自定义后置返回

```php
use think\bit\traits\DeleteModel;
use think\bit\lifecycle\DeleteAfterHooks;

class AdminClass extends Base implements DeleteAfterHooks {
    use DeleteModel;

    protected $model = 'admin';

    public function __deleteAfterHooks()
    {
        $this->delete_after_result = [
            'error'=> 1,
            'msg'=> 'error:redis'
        ];
        return false;
    }
}
```

### lifecycle 生命周期

- GetBeforeHooks 单条数据的通用请求处理前置自定义周期
  - \_\_getBeforeHooks() 单条数据前置周期
    - return `boolean`，返回值为 `false` 则在此结束执行
- GetCustom 单条数据的通用请求处理自定义返回周期
  - \_\_getCustomReturn($data) 单条数据前置周期
    - data `array` 原数据
- ListsBeforeHooks 分页数据的通用请求处理前置自定义周期
  - \_\_listsBeforeHooks() 分页数据前置周期
    - return `boolean`，返回值为 `false` 则在此结束执行
- ListsCustom 分页数据的通用请求处理自定义返回周期
  - \_\_listsCustomReturn(Array $lists, int $total) 分页数据自定义返回周期
    - lists `array` 原数据
    - total `int` 数据总数
- OriginListsBeforeHooks 列表数据请求前置处理周期
  - \_\_originListsBeforeHooks() 列表数据前置周期
    - return `boolean`，返回值为 `false` 则在此结束执行
- OriginListsCustom 列表数据的通用请求处理自定义返回周期
  - \_\_originListsCustomReturn(Array $lists) 列表数据自定义返回周期
    - lists `array` 原数据
- AddBeforeHooks 新增数据的通用请求处理前置自定义周期
  - \_\_addBeforeHooks() 新增前置周期
    - return `boolean`，返回值为 `false` 则在此结束执行
- AddAfterHooks 新增数据的通用请求处理后置自定义周期
  - \_\_addAfterHooks($pk) 新增后置周期
    - pk `string|int` 模型写入后返回的主键
    - return `boolean`，返回值为 `false` 则在此结束执行进行事务回滚
- EditBeforeHooks 编辑数据的通用请求处理前置自定义周期
  - \_\_editBeforeHooks() 编辑前置周期
    - return `boolean`，返回值为 `false` 则在此结束执行
- EditAfterHooks 编辑数据的通用请求处理后置自定义周期
  - \_\_editBeforeHooks() 编辑前置周期
    - return `boolean`，返回值为 `false` 则在此结束执行进行事务回滚
- DeleteBeforeHooks 删除数据的通用请求处理前置自定义周期
  - \_\_deleteBeforeHooks() 删除前置周期
    - return `boolean`，返回值为 `false` 则在此结束执行
- DeletePrepHooks 删除数据的通用请求处理在事务之后模型写入之前的的自定义周期
  - \_\_deletePrepHooks() 删除在事务之后模型写入之前的周期
    - return `boolean`，返回值为 `false` 则在此结束执行进行事务回滚
- DeleteAfterHooks 删除数据的通用请求处理后置自定义周期
  - \_\_deleteAfterHooks() 删除后置周期
    - return `boolean`，返回值为 `false` 则在此结束执行进行事务回滚
